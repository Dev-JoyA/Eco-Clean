{
  "_format": "hh3-sol-build-info-1",
  "id": "solc-0_8_28-7e0bea50f4e8625c37f0b7d875743da3362ae776",
  "solcVersion": "0.8.28",
  "solcLongVersion": "0.8.28+commit.7893614a",
  "userSourceNameMap": {
    "contracts/EcoClean.sol": "project/contracts/EcoClean.sol"
  },
  "input": {
    "language": "Solidity",
    "settings": {
      "evmVersion": "cancun",
      "optimizer": {
        "enabled": true,
        "runs": 200
      },
      "outputSelection": {
        "*": {
          "": [
            "ast"
          ],
          "*": [
            "abi",
            "evm.bytecode",
            "evm.deployedBytecode",
            "evm.methodIdentifiers",
            "metadata"
          ]
        }
      },
      "remappings": []
    },
    "sources": {
      "project/contracts/Admin.sol": {
        "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.28;\n\n\ncontract Admin { \n\n    address[] admins;\n    uint256 count;\n    uint256 public rate;\n\n    error NotAuthorised();\n    error InValid();\n\n    mapping(address => uint256) public adminId;\n    mapping(address => bool ) public isAdminRegistered;\n    mapping(uint256 => address) public idToAdmin;\n\n\n    function _onlyAdmin() private view {\n      if(!isAdminRegistered[msg.sender]){\n            revert NotAuthorised();\n        }\n\n    }\n\n    function _registerAdmin(address _admin) internal {\n        if(_admin == address(0)){\n            revert InValid();\n        }\n        require(!isAdminRegistered[_admin], \"Already Registered\");\n        admins.push(_admin);\n        count++;\n        isAdminRegistered[_admin] = true;\n        idToAdmin[count] = _admin;\n        adminId[_admin] = count;\n        idToAdmin[count] = _admin; \n    }\n\n    function _deleteAdmin(address _admin) internal {\n        _onlyAdmin();\n        for(uint256 i = 0; i < admins.length; i++){\n            if(admins[i] == _admin){\n                admins[i] = admins[admins.length - 1];\n                admins.pop();\n\n                uint256 _id = adminId[_admin];\n                delete adminId[_admin];\n                delete idToAdmin[_id];\n                isAdminRegistered[_admin] = false;\n                break;\n            }\n        }\n\n    }\n\n    function _deleteAdminById(uint256 id) internal {\n    _onlyAdmin();\n\n    address _admin = idToAdmin[id]; \n    require(_admin != address(0), \"Invalid ID\");\n\n    for(uint256 i = 0; i < admins.length; i++){\n        if(admins[i] == _admin){\n            admins[i] = admins[admins.length - 1];\n            admins.pop();\n\n            delete adminId[_admin];\n            delete idToAdmin[id];   \n            isAdminRegistered[_admin] = false;\n            break;\n        }\n    }\n}\n\n\n    function _setRate(uint256 _rate) internal{\n        _onlyAdmin();\n        rate = _rate;\n    }\n\n    function onlyAdmin() internal view {\n        _onlyAdmin();\n    }    \n\n}"
      },
      "project/contracts/EcoClean.sol": {
        "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.28;\n\nimport \"./Admin.sol\";\nimport \"./Product.sol\";\nimport \"./User.sol\";\nimport \"./library/ItemLib.sol\";\n\ncontract EcoClean is User, Admin, Product {\n    using ItemLib for string;\n    uint8 constant DECIMALS = 8;\n\n    enum ProductStatus {Available, NotAvailable}\n\n    struct Products {\n        uint256 productId;\n        string name;\n        uint256 quantity;\n        address owner;\n        bytes data;\n        uint256 amount;\n        ProductStatus productStatus;\n    }\n\n    struct RecycledItems{\n        uint256 itemId;\n        uint256 weight;\n        ItemLib.ItemType itemType;\n    }\n\n    mapping (address => mapping(uint256 => bool)) public isProducerPaidForProduct;\n    mapping (uint256 => mapping(uint256 => bool)) public hasUserReceivedPayment;\n\n    mapping (uint256 => mapping (uint256 => RecycledItems)) public itemByUserId;\n    mapping (uint256 => bool) public hasRecycled;\n    mapping (uint256 => uint256) public recycledItemId;\n\n   \n    mapping (uint256 => mapping(uint256 => Products)) public  allProductsByProducer;\n    //used for looking up a producer by his id;\n    mapping (uint256 => uint256) public productIdByOwner;\n    //producer id to number of product they have used for giving givingg id to a specific producer\n    mapping (uint256 => uint256) public productCountByOwner;\n    mapping (uint256 => bool) public validPid;\n    mapping (uint256 => uint256[]) public productsByProducerId;\n    mapping(uint256 => Products) public products;\n\n\n    error AlreadyPaid();\n    error ProductSoldOut();\n    error InsufficientPayment();\n    error InsufficientStock();\n\n    event ItemRecycled(address indexed user, uint256 itemId, string itemType, uint256 weight);\n    event PaidForRecycledItem(address indexed user, uint256 indexed userId, uint256 itemId, ItemLib.ItemType itemType);\n\n    function registerUser() public {\n        _registerUser(msg.sender);\n    }\n\n    function registerAdmin(address _admin) public {\n        _registerAdmin(_admin);\n    }\n\n    function registerProducer(string memory  _name, string memory _country, uint256 _number) public {\n        registerProductOwner(msg.sender, _name, _country, _number);    \n    }\n    \n    function recycleItem(string memory _type, uint256 _weight) public { \n        if(!_isRegistered(msg.sender)){\n             _registerUser(msg.sender);\n        }\n        require(_weight > 0, \"Invalid weight\");\n\n        uint256 id = userId[msg.sender];\n\n        recycledItemId[id]++;\n\n       itemByUserId[id][recycledItemId[id]] = RecycledItems({\n            itemId: recycledItemId[id],\n            weight: _weight,\n            itemType: _type.toItemType()\n        });\n\n        hasRecycled[id] = true;\n        hasUserReceivedPayment[id][recycledItemId[id]] = false;\n        emit ItemRecycled(msg.sender, recycledItemId[id], _type, _weight);\n    }\n\n    function payUser(uint256 _id, uint256 _rid) public payable {\n        onlyAdmin();\n        address user = userAccountId[_id].userAddress;\n        !_isRegistered(_id);\n        if(hasUserReceivedPayment[_id][_rid] == true){\n            revert AlreadyPaid();\n        }\n\n        uint256 itemWeight = itemByUserId[_id][_rid].weight;\n        ItemLib.ItemType _rType= itemByUserId[_id][_rid].itemType;\n        uint256 amount = ItemLib.toItemWeight(itemWeight, rate, _rType);\n\n        emit PaidForRecycledItem(user, _id, _rid, _rType);\n        // payable(user).transfer(amount * (10 ** DECIMALS));\n        (bool success, ) = payable(user).call{value: amount * (10 ** DECIMALS)}(\"\");\n        require(success, \"Transfer failed\");\n\n        hasUserReceivedPayment[_id][_rid] = true;   \n    }\n\n    function deleteUserAccount(address _user) public {\n        _deleteUser(_user);\n    }\n\n    function deleteAdmin(address _admin) public {\n        _deleteAdmin(_admin);\n    }\n\n    function deleteAdminById(uint256 _adminId) public {\n        _deleteAdminById(_adminId);\n    }\n\n    function setRate(uint256 _rate) public {\n        _setRate(_rate);\n    }\n\n    // PRODUCT ENDPOINT OR FUNCTIONS \n\n    function addProduct(uint256 _id, string memory _name, uint256 _quantity, bytes memory _data, uint256 _amount) public {\n        if(isProducerRegistered[_id] == false){\n            revert NotAuthorised();\n        }\n    \n        address _owner = registrationAddress[_id];\n\n        productOwner[_id] = _owner;\n\n        productCount++;\n\n        productCountByOwner[_id]++;\n        \n        allProductsByProducer[_id][productCountByOwner[_id]] = Products({\n            productId : productCountByOwner[_id],\n            name : _name,\n            quantity : _quantity,\n            owner : _owner,\n            data : _data,\n            amount : _amount * (10**DECIMALS),\n            productStatus : ProductStatus.Available\n        });\n\n        productIds.push(productCountByOwner[_id]);\n        productIdByOwner[productCountByOwner[_id]] = _id;\n        productsByProducerId[_id] = productIds; \n        validPid[productCountByOwner[_id]] = true;  \n        products[productCountByOwner[_id]] = Products({\n            productId : productCountByOwner[_id],\n            name : _name,\n            quantity : _quantity,\n            owner : _owner,\n            data : _data,\n            amount : _amount * (10**DECIMALS),\n            productStatus : ProductStatus.Available\n        });\n\n    }\n\n    function shopProduct(uint256 _pid, uint256 _quantity) public payable {\n        require(_pid > 0, \"Invalid product ID\");\n        require(validPid[_pid] == true, \"No product with that id\" );\n        uint256 _owner = productIdByOwner[_pid];\n        address _producer = productOwner[_owner];\n        Products storage product = allProductsByProducer[_owner][_pid]; \n\n        if(product.productStatus == ProductStatus.NotAvailable){\n            revert ProductSoldOut();\n        }\n\n        if (product.quantity < _quantity) {\n            revert InsufficientStock();\n        }\n\n        uint256 totalCost = _quantity * product.amount ;\n        require(msg.value == totalCost, \"Incorrect payment\");\n\n        productCount--;\n        productCountByOwner[_owner]--;\n        for(uint256 i = 0; i < productIds.length; i++){\n            if(productIds[i] == _pid){\n                productIds[i] = productIds[productIds.length - 1];\n                productIds.pop();\n                break;\n            }\n        }\n\n        product.quantity -= _quantity;\n        if (product.quantity == 0) {\n            product.productStatus = ProductStatus.NotAvailable;\n        }\n\n        uint256[] storage activeProduct = productsByProducerId[_owner];\n        for(uint256 i = 0; i < activeProduct.length; i++){\n            if(activeProduct[i] == _pid){\n                activeProduct[i] = activeProduct[activeProduct.length - 1];\n                activeProduct.pop();\n                break;\n            }\n        }\n        require(isProducerPaidForProduct[_producer][_pid] == false, \"Already paid producer \");\n        payable(_producer).transfer(msg.value);\n        isProducerPaidForProduct[_producer][_pid] = true;\n    }  \n\n    function fundContract() external payable {\n        require(msg.value > 0, \"Must send some HBAR\");\n    }\n\n    function contractBalance() external view returns (uint256) {\n        onlyAdmin();\n        return address(this).balance;\n    }\n\n\n    receive() external payable {}\n    fallback() external payable {}\n    \n}"
      },
      "project/contracts/library/ItemLib.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nlibrary ItemLib {\n    enum ItemType { PAPER, PLASTIC, METALS, GLASS, OTHERS }\n\n    function toItemType(string memory _type) internal pure returns (ItemType) {\n        bytes32 t = keccak256(bytes(_type));\n\n        if (t == keccak256(\"paper\")) {\n            return ItemType.PAPER;\n        } else if (t == keccak256(\"plastic\")) {\n            return ItemType.PLASTIC;\n        } else if (t == keccak256(\"metals\")) {\n            return ItemType.METALS;\n        } else if (t == keccak256(\"glass\")) {\n            return ItemType.GLASS;\n        } else {\n            return ItemType.OTHERS;\n        }\n    }\n\n    function toItemWeight(uint256 _weight, uint256 _rate, ItemType _type) internal pure returns (uint256){\n        if(_weight < 5){\n            return 0;\n        }\n\n        if(_type == ItemType.PAPER){\n            return (_weight * _rate);\n        }else if(_type == ItemType.GLASS){\n            return ((_weight * _rate) / 2 );\n        }else if(_type == ItemType.METALS){\n            return ((_weight * _rate) * 3);\n        }else if(_type == ItemType.PLASTIC){\n            return ((_weight * _rate) * 2);\n        }else if(_type == ItemType.OTHERS){\n            return ((_weight * _rate) / 3);\n        }else {\n            return 0;\n        }\n    }\n}\n"
      },
      "project/contracts/Product.sol": {
        "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.28;\n\ncontract Product {\n    uint256[] public productIds;\n    uint256 public productCount;\n    uint256 private registrationCount;\n\n    struct Details {\n        string name;\n        string country;\n        uint256 phoneNumber;\n    }\n\n    //registration id \n    mapping(uint256 => bool) public isProducerRegistered;\n    //registration id per details \n    mapping (uint256 => Details) public ownerDetails;\n    // check if its the owner of the product by id\n    mapping (uint256 => address) public productOwner;\n    //registration Id\n    mapping (address => uint256) public registrationId;\n    //registration Address\n    mapping (uint256 => address) public registrationAddress;\n\n    event ProductAdded(uint256 indexed id, address owner);\n\n    error AlreadyRegistered();\n    error Invalid(address);\n\n    function registerProductOwner (address _producer, string memory  _name, string memory _country, uint256 _number) internal {\n        if(_producer == address(0)){\n            revert Invalid(_producer);\n        }\n        if(registrationId[_producer] != 0){\n            revert AlreadyRegistered();\n        }\n\n        registrationCount++;\n        ownerDetails[registrationCount] = Details({\n            name : _name,\n            country : _country,\n            phoneNumber : _number\n        });\n\n        isProducerRegistered[registrationCount] = true;\n        registrationId[_producer] = registrationCount;\n        registrationAddress[registrationCount] = _producer; \n    }\n   \n\n    function getProductOwner(uint256 _id) internal view returns (address) {\n        require(isProducerRegistered[_id], \"Product not registered\");\n        return productOwner[_id];\n    }\n\n    function getAllProductIds() internal view returns (uint256[] memory) {\n        return productIds;\n    }\n\n    function totalProducts() internal view returns (uint256) {\n        return productCount;\n    }\n}\n"
      },
      "project/contracts/User.sol": {
        "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.28;\n\n\ncontract User{\n    address[] private users;\n    uint256 private count;\n\n    struct UserAccount {\n        uint256 id;\n        address userAddress;\n    }\n\n    //used to get userAccount id and address by id\n    mapping (uint256 => UserAccount) public userAccountId;\n\n    //used to get userAccount id by address\n    mapping (address => uint256) public userId;\n    \n    error NotFound();\n    error UserNotRegistered();\n   \n    function _registerUser(address _user) internal {\n        if(_user == address(0)){\n            revert NotFound();\n        }\n        require(userId[_user] == 0, \"user already have an id\");\n\n        count++;\n        userAccountId[count] = UserAccount({\n            id : count,\n            userAddress : _user\n        });\n\n        userId[_user] = count;\n        \n        users.push(_user);    \n    }\n\n    function _isRegistered(uint256 _id) internal view returns(bool){\n        if(userAccountId[_id].userAddress == address(0)){\n            revert UserNotRegistered();\n        }\n\n        return true;\n    }\n\n    function _isRegistered(address _user) internal view returns(bool) {\n        return userId[_user] != 0;   \n    }\n\n\n   function _deleteUser(address _user) internal {\n    if(_isRegistered(_user) == false){\n        revert NotFound();\n    }\n    for (uint256 i = 0; i < users.length; i++) {\n        if (users[i] == _user) {\n            users[i] = users[users.length - 1];\n            users.pop();\n            \n            uint256 id = userId[_user];\n            delete userAccountId[id];\n            delete userId[_user];\n            break;\n        }\n    }\n}\n\n\n}"
      }
    }
  }
}